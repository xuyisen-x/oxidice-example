import { i as R, __tla as __tla_0 } from "./Dice-CBTsIFS6.js";
import { __tla as __tla_1 } from "./dice-box.es-DxJcGGxK.js";
import { __tla as __tla_2 } from "./index-C0trF68s.js";
let T;
let __tla = Promise.all([
  (() => {
    try {
      return __tla_0;
    } catch {
    }
  })(),
  (() => {
    try {
      return __tla_1;
    } catch {
    }
  })(),
  (() => {
    try {
      return __tla_2;
    } catch {
    }
  })()
]).then(async () => {
  var I = Object.defineProperty, w = (t, e, i) => e in t ? I(t, e, {
    enumerable: true,
    configurable: true,
    writable: true,
    value: i
  }) : t[e] = i, m = (t, e, i) => (w(t, typeof e != "symbol" ? e + "" : e, i), i), f = (t, e, i) => {
    if (!e.has(t)) throw TypeError("Cannot " + i);
  }, o = (t, e, i) => (f(t, e, "read from private field"), e.get(t)), h = (t, e, i) => {
    if (e.has(t)) throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(t) : e.set(t, i);
  }, d = (t, e, i, a) => (f(t, e, "write to private field"), e.set(t, i), i), u = (t, e, i, a) => ({
    set _(s) {
      d(t, e, s);
    },
    get _() {
      return o(t, e);
    }
  }), g, n, c, l, p, v;
  T = class {
    constructor(e) {
      m(this, "config"), h(this, g, void 0), m(this, "initialized", false), h(this, n, {}), h(this, c, 0), h(this, l, 0), h(this, p, []), h(this, v, void 0), m(this, "noop", () => {
      }), this.onInitComplete = e.onInitComplete || this.noop, this.onThemeLoaded = e.onThemeLoaded || this.noop, this.onRollResult = e.onRollResult || this.noop, this.onRollComplete = e.onRollComplete || this.noop, this.onDieRemoved = e.onDieRemoved || this.noop, this.initialized = this.initScene(e);
    }
    async initScene(e) {
      this.config = e.options, this.onInitComplete();
    }
    resize() {
    }
    loadTheme() {
      return Promise.resolve();
    }
    updateConfig(e) {
      Object.assign(this.config, e);
    }
    addNonDie(e) {
      console.log("die", e), clearTimeout(o(this, v));
      const { id: i, value: a, ...s } = e, r = {
        id: i,
        value: a,
        config: s
      };
      o(this, n)[i] = r, o(this, p).push(setTimeout(() => {
        this.handleAsleep(r);
      }, u(this, c)._++ * this.config.delay)), d(this, v, setTimeout(() => {
        this.onRollComplete();
      }, 500));
    }
    add(e) {
      console.log("add die"), this.addNonDie(e);
    }
    remove(e) {
      console.log("remove die");
      const i = o(this, n)[e.id];
      i.hasOwnProperty("d10Instance") && (delete o(this, n)[i.d10Instance.id], u(this, l)._--), delete o(this, n)[e.id], u(this, l)._--, this.onDieRemoved(e.rollId);
    }
    clear() {
      !Object.keys(o(this, n)).length && !o(this, l) || (o(this, p).forEach((e) => clearTimeout(e)), Object.values(o(this, n)).forEach((e) => {
        e.mesh && e.mesh.dispose();
      }), d(this, n, {}), d(this, c, 0), d(this, l, 0));
    }
    async handleAsleep(e) {
      var i, a;
      if (e.asleep = true, await R.getRollResult(e), e.d10Instance || e.dieParent) {
        if ((i = e == null ? void 0 : e.d10Instance) != null && i.asleep || (a = e == null ? void 0 : e.dieParent) != null && a.asleep) {
          const s = e.config.sides === 100 ? e : e.dieParent, r = e.config.sides === 10 ? e : e.d10Instance;
          r.value === 0 && s.value === 0 ? s.value = 100 : s.value = s.value + r.value, this.onRollResult({
            rollId: s.config.rollId,
            value: s.value
          });
        }
      } else e.config.sides === 10 && e.value === 0 && (e.value = 10), this.onRollResult({
        rollId: e.config.rollId,
        value: e.value
      });
      u(this, l)._++;
    }
  };
  g = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap(), c = /* @__PURE__ */ new WeakMap(), l = /* @__PURE__ */ new WeakMap(), p = /* @__PURE__ */ new WeakMap(), v = /* @__PURE__ */ new WeakMap();
});
export {
  __tla,
  T as default
};
